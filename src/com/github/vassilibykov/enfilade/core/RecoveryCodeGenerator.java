// Copyright (c) 2018 Vassili Bykov. Licensed under the Apache License, Version 2.0.

package com.github.vassilibykov.enfilade.core;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.objectweb.asm.Label;
import org.objectweb.asm.Opcodes;

import java.lang.invoke.MethodType;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import static com.github.vassilibykov.enfilade.core.JvmType.BOOL;
import static com.github.vassilibykov.enfilade.core.JvmType.INT;
import static com.github.vassilibykov.enfilade.core.JvmType.REFERENCE;

/**
 * A code generator producing recovery code of a function implementation. The
 * code follows the "normal" code generated by {@link MethodCodeGenerator} in
 * the same JVM method. An SPE handler jumps into the recovery code after
 * unwrapping the SPE to have its value on the stack and "unspecializing" any
 * live locals (replacing primitive values with wrapper objects).
 *
 * <p>The simple way to generate recovery code would be with a regular {@link
 * EvaluatorNode.Visitor}, generating an entire second copy of the function with
 * all operations being generic. However, because recovery code is only
 * accessible via jumps from SPE handlers, large portions of it end up being
 * dead code and are erased by ASM, replaced with unsightly swathes of {@code
 * nop}s. For more eye-pleasing results, we follow a somewhat more involved
 * approach.
 *
 * <p>TODO elaborate
 */
class RecoveryCodeGenerator {

    /**
     * An instruction of A-code.
     *
     * <p>A-code is a representation of A-normal forms in a shape resembling a
     * sequence of instructions. It can be executed by A-machine which consists
     * of a vector of local variable values, a current instruction pointer,
     * and a single register.
     *
     * <p>There are only six instructions. Instruction arguments, when present,
     * are actual objects of the specified types.
     *
     * <ul>
     *     <li>load EvaluatorNode (for an atomic expression or a call)/li>
     *     <li>store VariableDefinition</li>
     *     <li>copy VariableDefinition</li>
     *     <li>branch EvaluatorNode int</li>
     *     <li>goto int</li>
     *     <li>return</li>
     * </ul>
     */
    static abstract class Instruction {
        private boolean isLive;
        @Nullable Label incomingJumpLabel;
        abstract void accept(RecoveryCodeGenerator visitor);
    }

    private static abstract class JumpInstruction extends Instruction {
        /** Jump target address in the originally generated code, invalid after dead code elimination. */
        int address;
        /** The instruction pointed to by {@link #address}. */
        Instruction target;

        private JumpInstruction(int address) {
            this.address = address;
        }
    }

    /**
     * Set the instruction pointer to the specified address if the test evaluates to
     * true.
     */
    private static class Branch extends JumpInstruction {
        final EvaluatorNode test;

        Branch(EvaluatorNode test, int address) {
            super(address);
            this.test = test;
        }

        @Override
        public void accept(RecoveryCodeGenerator visitor) {
            visitor.visitBranch(this);
        }

        @Override
        public String toString() {
            return "BRANCH " + address + " " + test;
        }
    }

    /**
     * Unconditionally set the instruction pointer to the specified address.
     */
    private static class Goto extends JumpInstruction {
        Goto(int address) {
            super(address);
        }

        @Override
        public void accept(RecoveryCodeGenerator visitor) {
            visitor.visitGoto(this);
        }

        @Override
        public String toString() {
            return "GOTO " + address;
        }
    }

    /**
     * Evaluate the atomic expression and set the value register to contain the result.
     */
    private static class Load extends Instruction {
        @NotNull final EvaluatorNode expression;

        Load(@NotNull EvaluatorNode expression) {
            this.expression = expression;
        }

        @Override
        public void accept(RecoveryCodeGenerator visitor) {
            visitor.visitLoad(this);
        }

        @Override
        public String toString() {
            return "LOAD " + expression;
        }
    }

    /**
     * Return the value of the register as the result of this invocation.
     */
    private static class Return extends Instruction {
        final RecoverySite recoverySite;

        Return(RecoverySite recoverySite) {
            this.recoverySite = recoverySite;
        }

        @Override
        public void accept(RecoveryCodeGenerator visitor) {
            visitor.visitReturn(this);
        }

        @Override
        public String toString() {
            return "RETURN";
        }
    }

    /**
     * Store the value of the register in the specified local variable.
     */
    private static class Store extends Instruction {
        @NotNull final AbstractVariable variable;
        final RecoverySite recoverySite;

        Store(@NotNull AbstractVariable variable, RecoverySite recoverySite) {
            this.variable = variable;
            this.recoverySite = recoverySite;
        }

        @Override
        public void accept(RecoveryCodeGenerator visitor) {
            visitor.visitStore(this);
        }

        @Override
        public String toString() {
            return "STORE " + variable;
        }
    }

    private static class Copy extends Store {
        Copy(@NotNull AbstractVariable variable, RecoverySite recoverySite) {
            super(variable, recoverySite);
        }

        @Override
        public void accept(RecoveryCodeGenerator visitor) {
            visitor.visitCopy(this);
        }
    }

    /**
     * Translates a tree if {@link EvaluatorNode}s implementing an expression in
     * A-normal form expression into the equivalent A-code.
     */
    static class EvaluatorNodeToACodeTranslator implements EvaluatorNode.Visitor<Void> {
        static Instruction[] translate(EvaluatorNode functionBody) {
            var translator = new EvaluatorNodeToACodeTranslator(functionBody);
            return translator.translate();
        }

        private class LivenessMapper {
            private final List<Integer> threads = new ArrayList<>(entryPoints);

            void map() {
                while (!threads.isEmpty()) {
                    var thread = threads.remove(0);
                    map(thread);
                }
            }

            private void map(int address) {
                var instruction = code.get(address);
                while (!instruction.isLive) {
                    instruction.isLive = true;
                    if (instruction instanceof Goto) {
                        address = ((Goto) instruction).address;
                    } else if (instruction instanceof Branch) {
                        threads.add(((Branch) instruction).address);
                        address++;
                    } else {
                        address++;
                    }
                    if (address >= code.size()) return;
                    instruction = code.get(address);
                }
            }
        }

        /*
            Instance
         */

        private final EvaluatorNode functionBody;
        private final List<Instruction> code = new ArrayList<>();
        private List<Integer> entryPoints = new ArrayList<>();

        private EvaluatorNodeToACodeTranslator(EvaluatorNode functionBody) {
            this.functionBody = functionBody;
        }

        Instruction[] translate() {
            functionBody.accept(this); // populates 'code' and 'entryPoints'
            emit(new Return(null));
            assignJumpLabels();
            analyzeLiveness();
            removeDeadCode();
            return code.toArray(new Instruction[0]);
        }

        private void assignJumpLabels() {
            for (var instruction : code) {
                if (instruction instanceof JumpInstruction) {
                    JumpInstruction jump = (JumpInstruction) instruction;
                    int targetAddress = jump.address;
                    var target = code.get(targetAddress);
                    jump.target = target;
                    target.incomingJumpLabel = new Label();
                }
            }
        }

        private void analyzeLiveness() {
            var mapper = new LivenessMapper();
            mapper.map();
        }

        private void removeDeadCode() {
            List<Instruction> entries = entryPoints.stream()
                .map(code::get)
                .collect(Collectors.toList());
            code.removeIf(instruction -> !instruction.isLive);
            List<Instruction> redundantGotos = new ArrayList<>();
            for (int i = 0; i < code.size() - 1; i++) {
                var instruction = code.get(i);
                if (instruction instanceof Goto && ((Goto) instruction).target == code.get(i + 1)) {
                    redundantGotos.add(instruction);
                }
            }
            code.removeAll(redundantGotos);
            entryPoints = entries.stream()
                .map(code::indexOf)
                .collect(Collectors.toList());
        }

        @Override
        public Void visitCall0(CallNode.Call0 call) {
            emit(new Load(call));
            return null;
        }

        @Override
        public Void visitCall1(CallNode.Call1 call) {
            emit(new Load(call));
            return null;
        }

        @Override
        public Void visitCall2(CallNode.Call2 call) {
            emit(new Load(call));
            return null;
        }

        @Override
        public Void visitDirectCall0(CallNode.DirectCall0 call) {
            emit(new Load(call));
            return null;
        }

        @Override
        public Void visitDirectCall1(CallNode.DirectCall1 call) {
            emit(new Load(call));
            return null;
        }

        @Override
        public Void visitDirectCall2(CallNode.DirectCall2 call) {
            emit(new Load(call));
            return null;
        }

        @Override
        public Void visitClosure(ClosureNode closure) {
            emit(new Load(closure));
            return null;
        }

        @Override
        public Void visitConstant(ConstantNode aConst) {
            emit(new Load(aConst));
            return null;
        }

        @Override
        public Void visitConstantFunction(DirectFunctionNode constFunction) {
            emit(new Load(constFunction));
            return null;
        }

        @Override
        public Void visitIf(IfNode anIf) {
            var branch = new Branch(anIf.condition(), Integer.MAX_VALUE);
            emit(branch);
            anIf.falseBranch().accept(this);
            var theGoto = new Goto(Integer.MAX_VALUE);
            emit(theGoto);
            branch.address = nextInstructionAddress();
            anIf.trueBranch().accept(this);
            theGoto.address = nextInstructionAddress();
            return null;
        }

        @Override
        public Void visitLet(LetNode let) {
            let.initializer().accept(this);
            entryPoints.add(nextInstructionAddress());
            emit(new Store(let.variable(), let));
            let.body().accept(this);
            return null;
        }

        @Override
        public Void visitLetrec(LetrecNode letrec) {
            emit(new Load(new ConstantNode(null)));
            emit(new Store(letrec.variable(), null));
            letrec.initializer().accept(this);
            entryPoints.add(nextInstructionAddress());
            emit(new Store(letrec.variable(), letrec));
            letrec.body().accept(this);
            return null;
        }

        @Override
        public Void visitPrimitive1(Primitive1Node primitive) {
            emit(new Load(primitive));
            return null;
        }

        @Override
        public Void visitPrimitive2(Primitive2Node primitive) {
            emit(new Load(primitive));
            return null;
        }

        @Override
        public Void visitBlock(BlockNode block) {
            EvaluatorNode[] expressions = block.expressions();
            if (expressions.length == 0) {
                emit(new Load(new ConstantNode(null)));
            } else {
                for (var each : expressions) each.accept(this);
            }
            return null;
        }

        @Override
        public Void visitReturn(ReturnNode ret) {
            ret.value().accept(this);
            entryPoints.add(nextInstructionAddress());
            emit(new Return(ret));
            return null;
        }

        @Override
        public Void visitSetVar(SetVariableNode set) {
            set.value().accept(this);
            entryPoints.add(nextInstructionAddress());
            emit(new Copy(set.variable(), set));
            return null;
        }

        @Override
        public Void visitGetVar(GetVariableNode varRef) {
            emit(new Load(varRef));
            return null;
        }

        private void emit(Instruction instruction) {
            code.add(instruction);
        }

        private int nextInstructionAddress() {
            return code.size();
        }
    }

    private class AtomicExpressionCodeGenerator implements EvaluatorNode.Visitor<JvmType> {
        @Override
        public JvmType visitCall0(CallNode.Call0 call) {
            call.function().accept(this); // puts a value on the stack that must be a closure
            var type = MethodType.genericMethodType(1); // Closure is the argument
            writer.invokeDynamic(
                ClosureInvokeDynamic.BOOTSTRAP,
                "call0",
                type);
            return REFERENCE;
        }

        @Override
        public JvmType visitCall1(CallNode.Call1 call) {
            call.function().accept(this); // puts a value on the stack which must be a closure
            var argType = call.arg().accept(this);
            var type = MethodType.genericMethodType(2);
            writer.adaptValue(argType, REFERENCE);
            writer.invokeDynamic(
                ClosureInvokeDynamic.BOOTSTRAP,
                "call1",
                type);
            return REFERENCE;
        }

        @Override
        public JvmType visitCall2(CallNode.Call2 call) {
            call.function().accept(this); // puts a value on the stack that must be a closure
            var arg1Type = call.arg1().accept(this);
            var type = MethodType.genericMethodType(3);
            writer.adaptValue(arg1Type, REFERENCE);
            var arg2Type = call.arg2().accept(this);
            writer.adaptValue(arg2Type, REFERENCE);
            writer.invokeDynamic(
                ClosureInvokeDynamic.BOOTSTRAP,
                "call2",
                type);
            return REFERENCE;
        }

        @Override
        public JvmType visitClosure(ClosureNode closure) {
            var indicesToCopy = closure.copiedVariableIndices;
            writer.newObjectArray(indicesToCopy.length);
            for (int i = 0; i < indicesToCopy.length; i++) {
                writer
                    .dup()
                    .loadInt(i)
                    .loadLocal(REFERENCE, indicesToCopy[i]);
                writer.asm().visitInsn(Opcodes.AASTORE);
            }
            writer
                .loadInt(closure.function().id())
                .invokeStatic(Closure.class, "create", Closure.class, Object[].class, int.class);
            return REFERENCE;
        }

        @Override
        public JvmType visitConstant(ConstantNode aConst) {
            Object value = aConst.value();
            if (value instanceof Integer) {
                writer.loadInt((Integer) value);
                return INT;
            } else if (value instanceof String) {
                writer.loadString((String) value);
                return REFERENCE;
            } else if (value == null) {
                writer.loadNull();
                return REFERENCE;
            } else if (value instanceof Boolean) {
                writer.loadInt((Boolean) value ? 1 : 0);
                return BOOL;
            } else {
                throw new CompilerError("unexpected const value: " + value);
            }
        }

        @Override
        public JvmType visitDirectCall0(CallNode.DirectCall0 call) {
            var type = MethodType.genericMethodType(0);
            writer.invokeDynamic(
                ConstantFunctionInvokeDynamic.BOOTSTRAP,
                "call0",
                type,
                call.target().id());
            return REFERENCE;
        }

        @Override
        public JvmType visitDirectCall1(CallNode.DirectCall1 call) {
            var type = MethodType.genericMethodType(1);
            var argType = call.arg().accept(this);
            writer.adaptValue(argType, REFERENCE);
            writer.invokeDynamic(
                ConstantFunctionInvokeDynamic.BOOTSTRAP,
                "call1",
                type,
                call.target().id());
            return REFERENCE;
        }

        @Override
        public JvmType visitDirectCall2(CallNode.DirectCall2 call) {
            var type = MethodType.genericMethodType(2);
            var arg1Type = call.arg1().accept(this);
            writer.adaptValue(arg1Type, REFERENCE);
            var arg2Type = call.arg2().accept(this);
            writer.adaptValue(arg2Type, REFERENCE);
            writer.invokeDynamic(
                ConstantFunctionInvokeDynamic.BOOTSTRAP,
                "call2",
                type,
                call.target().id());
            return REFERENCE;
        }

        @Override
        public JvmType visitGetVar(GetVariableNode getVar) {
            var variable = getVar.variable();
            writer.loadLocal(REFERENCE, variable.index());
            if (variable.isBoxed()) writer.extractBoxedVariable();
            return REFERENCE;
        }

        @Override
        public JvmType visitIf(IfNode anIf) {
            throw new UnsupportedOperationException("should not be called");
        }

        @Override
        public JvmType visitLet(LetNode let) {
            throw new UnsupportedOperationException("should not be called");
        }

        @Override
        public JvmType visitLetrec(LetrecNode letrec) {
            throw new UnsupportedOperationException("should not be called");
        }

        @Override
        public JvmType visitPrimitive1(Primitive1Node primitive1) {
            JvmType argType = primitive1.argument().accept(this);
            return primitive1.implementation().generate(writer, argType);
        }

        @Override
        public JvmType visitPrimitive2(Primitive2Node primitive2) {
            JvmType arg1Type =  primitive2.argument1().accept(this);
            JvmType arg2Type = primitive2.argument2().accept(this);
            return primitive2.implementation().generate(writer, arg1Type, arg2Type);
        }

        @Override
        public JvmType visitBlock(BlockNode block) {
            throw new UnsupportedOperationException("should not be called");
        }

        @Override
        public JvmType visitReturn(ReturnNode ret) {
            throw new UnsupportedOperationException("should not be called");
        }

        @Override
        public JvmType visitSetVar(SetVariableNode setVar) {
            throw new UnsupportedOperationException("should not be called");
        }

        @Override
        public JvmType visitConstantFunction(DirectFunctionNode constFunction) {
            int id = constFunction.id();
            writer
                .loadInt(id)
                .invokeStatic(CallableRegistry.class, "lookupAndMakeClosure", Closure.class, int.class);
            return REFERENCE;
        }
        }


    /*
        Instance
     */

    private final FunctionImplementation function;
    private final Instruction[] acode;
    protected final GhostWriter writer;
    private final AtomicExpressionCodeGenerator atomicGenerator;

    RecoveryCodeGenerator(FunctionImplementation function, GhostWriter writer) {
        this.function = function;
        /* TODO In principle, acode has the same structure for both generic and specialized
           forms of a function. However, there are issues with caching and reusing it
           which appear to have something to do with Labels--even if local labels are reassigned.
           See why that is and how we can fix the reuse. */
        this.acode = EvaluatorNodeToACodeTranslator.translate(function.body());
        this.writer = writer;
        this.atomicGenerator = new AtomicExpressionCodeGenerator();
    }

    void generate() {
        for (int i = 0; i < acode.length - 1; i++) {
            var instruction = acode[i];
            if (instruction.incomingJumpLabel != null) {
                writer.setLabelHere(instruction.incomingJumpLabel);
            }
            instruction.accept(this);
        }
        var finalReturn = acode[acode.length - 1];
        if (finalReturn.incomingJumpLabel != null) writer.setLabelHere(finalReturn.incomingJumpLabel);
        writer.bridgeValue(REFERENCE, function.specializedReturnType);
        writer.ret(function.specializedReturnType);
    }

    private void visitBranch(Branch branch) {
        var valueType = branch.test.accept(atomicGenerator);
        writer.adaptValue(valueType, BOOL);
        writer.jumpIfNot0(branch.target.incomingJumpLabel);
    }

    private void visitGoto(Goto aGoto) {
        writer.jump(aGoto.target.incomingJumpLabel);
    }

    private void visitLoad(Load load) {
        var valueType = load.expression.accept(atomicGenerator);
        writer.adaptValue(valueType, REFERENCE);
    }

    private void visitReturn(Return aReturn) {
        if (aReturn.recoverySite != null) setRecoveryLabelHere(aReturn.recoverySite);
        writer.ret(REFERENCE);
    }

    private void visitStore(Store store) {
        if (store.recoverySite != null) setRecoveryLabelHere(store.recoverySite);
        writer.storeLocal(REFERENCE, store.variable.index());
    }

    private void visitCopy(Copy copy) {
        setRecoveryLabelHere(copy.recoverySite);
        writer
            .dup()
            .storeLocal(REFERENCE, copy.variable.index());
    }

    private void setRecoveryLabelHere(RecoverySite site) {
        writer.setLabelHere(site.recoverySiteLabel());
    }

}
